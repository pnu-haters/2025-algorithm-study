# 문제
**제목**: 문자열 교환  
**시간 제한**: 2 초  
**메모리 제한**: 128 MB  

**설명**: 
a와 b로만 이루어진 문자열이 주어질 때,  a를 모두 연속으로 만들기 위해서 필요한 교환의 회수를 최소로 하는 프로그램을 작성하시오.
이 문자열은 원형이기 때문에, 처음과 끝은 서로 인접해 있는 것이다.
예를 들어,  aabbaaabaaba이 주어졌을 때, 2번의 교환이면 a를 모두 연속으로 만들 수 있다.
  
**입력**: 
첫째 줄에 문자열이 주어진다. 문자열의 길이는 최대 1,000이다.
  
**출력**: 
첫째 줄에 필요한 교환의 회수의 최솟값을 출력한다.
  


## Jimin-K04
BOJ_1522_문자열교환.cpp

```cpp
/*a 의 개수를 센다
* a 의 개수만큼의 크기의 윈도우 설정한다
* 원형이기 때문에 두포인터 값 주의해서 설정
* 해당 구간 밖에 있는 a 의 갯수를 세면 된다.
* 포인터를 옮겨가면서 새로 추가되는 a 의 갯수를 센다.
* min_exchange 값을 갱신하면서,, 구한다.
*/
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string str;
	cin >> str;

	int a_cnt = 0;
	int str_len = str.size();
	for (int i = 0; i < str_len; i++) {
		if (str[i] == 'a') a_cnt++;
	}

	int left = 0, right = a_cnt-1; //두 포인터 설정
	int min_exchange, window_a_cnt = 0; //최소 교환 횟수, 현재 윈도우 내 a 의 개수 저장.

	for (int i = left; i <= right; i++) {
		if (str[i] == 'a') window_a_cnt++;
	}
	min_exchange = a_cnt - window_a_cnt;

	while (left < str_len) {
		if (str[left] == 'a') window_a_cnt--;
		left++;
		right = (right + 1) % str_len;
		if (str[right] == 'a') window_a_cnt++;
		min_exchange = min(min_exchange, a_cnt - window_a_cnt);
	}
	   
	cout << min_exchange;
}
```

### 1. 좋은 점
- **효율적인 슬라이딩 윈도우 사용**: `a`의 개수만큼의 윈도우를 설정하고, 이를 순회하면서 최소 교환 횟수를 계산하는 방식이 매우 효율적입니다. 특히 원형 문자열을 처리하기 위해 `right` 포인터를 모듈로 연산(`% str_len`)으로 관리한 점이 인상적입니다.
- **명확한 변수 네이밍과 구조**: 변수명이 직관적이며, 윈도우 내 `a`의 개수를 추적하는 로직이 명확하게 구현되어 있어 코드의 가독성이 높습니다. 또한, 초기 윈도우 설정과 슬라이딩 과정이 잘 분리되어 있어 이해하기 쉽습니다.
- **효율적인 초기 계산**: 초기 윈도우 내 `a`의 개수를 한 번에 계산한 후, 슬라이딩하면서 필요한 부분만 업데이트하는 방식은 불필요한 반복을 피하고 성능을 최적화합니다.

### 2. 개선 및 보완이 필요한 점
- **경계 조건 처리의 명확성**: `a`의 개수가 0이거나 문자열 전체가 `a`로만 이루어진 경우와 같은 극단적인 입력에 대한 별도의 처리가 부족합니다. 예를 들어, `a_cnt`가 0인 경우 `min_exchange`가 음수가 될 가능성이 있으므로 이를 방지하는 로직이 필요합니다.
- **윈도우 슬라이딩 범위 최적화**: 현재 `left` 포인터가 `str_len`까지 이동하며 모든 윈도우를 검사하지만, 실제로는 `str_len`만큼만 윈도우를 이동해도 충분합니다. 따라서 `while (left < str_len)` 대신 `while (left < str_len + a_cnt)`와 같이 범위를 조정하여 불필요한 계산을 줄일 수 있습니다.
- **변수 초기화의 명확성**: `min_exchange` 변수가 초기화되는 시점과 그 값이 분명히 설정되는지 코드 상에서 명확하지 않습니다. 초기화 전에 `a_cnt`가 0인 경우를 처리하면 더 안전할 것입니다.

### 3. 생각해볼 부분
- **원형 문자열 처리의 일반화**: 현재 원형 문자열을 처리하기 위해 `right` 포인터를 모듈로 연산으로 관리하고 있습니다. 이러한 접근 방식이 다른 종류의 원형 문제에도 적용 가능한지, 또는 더 일반화된 방식으로 원형성을 처리할 수 있는지 고민해볼 수 있습니다.
- **교환 횟수의 정확성 검증**: 슬라이딩 윈도우 방식으로 계산한 `min_exchange`가 실제 최소 교환 횟수와 항상 일치하는지에 대한 이론적 증명이 필요합니다. 특히, 특정 패턴의 문자열에서 이 방법이 항상 최적해를 보장하는지 검토해볼 필요가 있습니다.
- **대체 알고리즘 탐색**: 슬라이딩 윈도우 외에, 예를 들어 `a`의 위치를 기준으로 최소 이동 거리를 계산하는 방법 등 다른 알고리즘적 접근 방법을 고려해볼 수 있습니다. 이를 통해 현재 방법과의 성능 및 정확성을 비교 분석할 수 있습니다.

---

전반적으로 코드가 문제를 효과적으로 해결하고 있으며, 논리 구조도 명확합니다. 다만, 경계 조건 처리와 일부 최적화 가능성을 고려하면 더욱 견고한 솔루션이 될 것입니다. 추가적으로, 알고리즘의 이론적 배경을 깊이 이해하고 대체 방법을 탐색해보는 것도 좋은 학습이 될 것입니다.

## Leeseojun035
BOJ_1522_문자열 교환.cpp

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

string s;
cin >> s;
int n = s.size();


int total_a = count(s.begin(), s.end(), 'a');
// 만약 모든 문자가 a이거나 a가 하나도 없으면 교환 불필요.
if(total_a == 0 || total_a == n){
    cout << 0;
    return 0;
}

// 처음 윈도우: 인덱스 0부터 total_a-1까지
int current_a = 0;
for(int i = 0; i < total_a; i++){
    if(s[i] == 'a')
        current_a++;
}
int max_a = current_a;

// 원형 슬라이딩 윈도우: 시작점을 1부터 n-1까지 이동
for (int i = 1; i < n; i++){
    // 기존 윈도우의 왼쪽 제거
    if(s[i - 1] == 'a')
        current_a--;
    
    int newIndex = (i + total_a - 1) % n;
    if(s[newIndex] == 'a')
        current_a++;

    max_a = max(max_a, current_a);
}


cout << total_a - max_a;
return 0;
}

```

### 1. 좋은 점
- **효율적인 알고리즘 사용**: 전체 'a'의 개수를 기반으로 슬라이딩 윈도우 기법을 적용하여 문제를 O(n) 시간 복잡도로 효율적으로 해결하였습니다. 이는 입력 크기 최대 1,000에서도 빠르게 동작할 수 있습니다.
- **원형 처리의 정확성**: 문자열이 원형임을 고려하여 슬라이딩 윈도우를 구현할 때 인덱스 계산에 모듈로 연산을 사용함으로써 처음과 끝이 연결된 경우도 정확히 처리하였습니다.
- **입력 예외 처리**: 모든 문자가 'a'이거나 'a'가 하나도 없는 경우를 빠르게 처리하여 불필요한 계산을 피하고, 즉시 결과를 출력하도록 하였습니다.

### 2. 개선 및 보완이 필요한 점
- **변수명 명확성**: `current_a`와 `max_a`와 같은 변수명이 현재 윈도우 내 'a'의 수와 최대 'a'의 수를 나타내지만, 더 직관적인 이름(예: `window_a_count`, `max_a_count`)을 사용하면 가독성이 향상될 수 있습니다.
- **코드 중복 최소화**: 초기 윈도우의 'a' 개수를 세는 부분과 슬라이딩 시 'a'를 추가/제거하는 부분에서 약간의 중복이 발생할 수 있습니다. 이를 함수로 분리하여 코드의 재사용성을 높일 수 있습니다.
- **주석 보완**: 코드에 주석이 일부 있지만, 전체적인 알고리즘의 흐름과 각 단계의 목적을 좀 더 상세히 설명하는 주석이 추가되면 이해하기 더 쉬워질 것입니다.

### 3. 생각해볼 부분
- **최적의 교환 방법 탐색**: 현재 알고리즘은 최소 교환 횟수를 계산하지만, 실제로 어떤 교환을 수행해야 하는지에 대한 정보는 제공하지 않습니다. 스터디 과정에서 교환의 구체적인 방법을 구현하거나 시각화하는 방법을 고민해볼 수 있습니다.
- **다른 접근 방식 비교**: 슬라이딩 윈도우 외에도 투 포인터 방식이나 비트마스크 등을 활용한 다른 알고리즘적 접근이 가능한지 탐색해보는 것도 유익할 것입니다. 이를 통해 다양한 알고리즘의 장단점을 비교하고 이해할 수 있습니다.
- **확장된 문제 조건 고려**: 예를 들어, 문자열에 'a'와 'b' 외의 문자가 포함되거나, 교환 비용이 다를 경우 같은 접근법이 여전히 유효한지, 아니면 새로운 전략이 필요한지 등을 고민해보는 것도 알고리즘적 사고를 확장하는 데 도움이 될 것입니다.

## Nayeeun5
BOJ_1522_문자열 교환.cpp

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    string str;
    cin >> str;

    int n = str.size();
    int a = count(str.begin(), str.end(), 'a'); // a의 개수
    int b = 0, ans;

    for (int i = 0; i < a; i++) {
        if (str[i] == 'b') b++;
    }
    ans = b;

    for (int i = 0; i < n; ++i) {
        if (str[i] == 'b') b--; // 앞쪽 문자가 b면 제외
        if (str[(i + a) % n] == 'b') b++; // 새로 포함되는 문자가 b면 추가
        ans = min(ans, b);
    }

    cout << ans;
}

```

### 1. 좋은 점
- **효율적인 슬라이딩 윈도우 구현**: `a`의 개수를 기준으로 윈도우를 설정하고, 이를 슬라이딩하면서 `b`의 개수를 세는 방식은 문제의 요구사항을 효과적으로 충족시킵니다. 특히 원형 문자열을 고려하여 인덱스를 `% n`으로 처리한 점이 잘 구현되었습니다.
- **최소값 갱신 방식**: 초기 윈도우의 `b` 개수를 `ans`에 저장한 후, 슬라이딩하면서 최소값을 지속적으로 갱신하는 로직이 직관적이고 효율적입니다.
- **입력 최적화**: `ios::sync_with_stdio(0);`와 `cin.tie(0);`을 사용하여 입력 속도를 최적화한 점이 좋습니다. 이는 대규모 입력에서도 성능을 보장하는 데 도움이 됩니다.

### 2. 개선 및 보완이 필요한 점
- **변수명 명확성**: 변수 `a`와 `b`가 각각 문자 `'a'`의 개수와 현재 윈도우 내 `'b'`의 개수를 나타내는 점에서, 가독성을 높이기 위해 더 명확한 이름(예: `count_a`, `current_b`)을 사용하는 것이 좋습니다.
- **엣지 케이스 처리 부족**: 문자열에 `'a'`가 전혀 없거나, 모든 문자가 `'a'`인 경우 등 엣지 케이스에 대한 처리가 명확하지 않습니다. 이러한 경우에도 코드가 올바르게 동작하는지 확인이 필요합니다.
- **최소값 초기화 방식**: `ans`를 첫 번째 윈도우의 `b` 개수로 초기화하는 방식은 일반적이지만, 보다 안전하게 `INT_MAX`로 초기화한 후 최소값을 갱신하는 방식도 고려해볼 수 있습니다.
- **주석 부족**: 코드의 주요 로직에 대한 주석이 부족하여, 코드의 의도를 파악하는 데 시간이 걸릴 수 있습니다. 중요한 부분에는 주석을 추가하여 가독성을 높이는 것이 좋습니다.

### 3. 생각해볼 부분
- **시간 복잡도 분석**: 현재 구현은 문자열 길이 `n`에 대해 `O(n)`의 시간 복잡도를 가지므로, 입력 제한인 1,000 내에서는 충분히 효율적입니다. 그러나 더 큰 입력에 대비해 알고리즘의 확장성을 고려해볼 수 있습니다.
- **다른 접근 방식 비교**: 슬라이딩 윈도우 외에도, 투 포인터나 다른 최적화 기법을 적용할 수 있는지 탐구해보는 것도 유익할 것입니다. 예를 들어, 문자열을 두 번 이어붙인 후 슬라이딩 윈도우를 적용하는 방식도 고려해볼 수 있습니다.
- **원형 문자열 처리의 일반화**: 현재는 원형 문자열을 처리하기 위해 `% n` 연산을 사용하고 있지만, 이를 일반화하여 다른 형태의 원형 데이터 처리에도 응용할 수 있는지 고민해볼 수 있습니다.
- **코드 최적화**: 현재는 매 슬라이딩 시마다 `min` 함수를 호출하고 있는데, 이러한 호출을 줄일 수 있는 최적화 방법이 있는지 탐구해보는 것도 좋습니다.

전체적으로 매우 효율적이고 문제의 요구사항을 잘 충족시키는 코드입니다. 약간의 개선을 통해 가독성과 안정성을 더욱 높일 수 있을 것으로 보입니다.

## cjaewon
BOJ_1522_문자열 교환.py

```py
"""
슬라이딩 윈도우를 이용하여 푸는 문제이다.

먼저 aabbaaabaaba를 입력받았다고 해보자.
aabbaaabaaba에서 a는 8개, b는 4개

a부터 계산해보자.

입력받은 aabbaaabaaba에 대해 반복문을 돌려 각각의 인덱스를 포함한 8개를 윈도우에 대해 계산한다.
처음으로 인덱스가 1인 경우에는 윈도우 안에 aabbaaab이 포함된다. 

여기서는 모두 a로 만들기 위해 필요한 교환 개수는 3이다.
이를 계속 반복하면 a의 경우 최소 교환 개수를 구할 수 있다.

마찬가지로 b 또한 계산해서 a와 b를 비교하여 최소를 구해준다.

원형 배열를 위해 deque를 사용하고 rotate 함수를 이용하여 돌려주었다.
+ 추가적인 생각
슬라이딩 윈도우라는 개념에 더 부합할려면 기존에 있던 윈도우의 데이터를 활용해야하지 않을까?
추가되는 부분과 빼지는 부분만을 처리한다면 더 효율적인 구현인듯 싶음.
"""

from collections import deque

chars = list(input())
dq = deque(chars)

a_window = chars.count("a")
b_window = chars.count("b")

min_swap = 1e9

for i in range(len(chars)):
  swap_count = 0

  for j in range(a_window):
    if dq[j] != "a":
      swap_count += 1

  if min_swap > swap_count:
    min_swap = swap_count

  dq.rotate(1)

for i in range(len(chars)):
  swap_count = 0

  for j in range(b_window):
    if dq[j] != "b":
      swap_count += 1

  if min_swap > swap_count:
    min_swap = swap_count

  dq.rotate(1)

print(min_swap)
```

### 1. 좋은 점
- **슬라이딩 윈도우 접근 방식 사용**: 문자열 내에서 연속된 'a' 또는 'b'를 찾기 위해 슬라이딩 윈도우 기법을 적용한 점이 효율적입니다. 이로 인해 문제의 요구사항을 잘 충족시키고 있습니다.
- **원형 배열 처리**: `deque`와 `rotate` 함수를 사용하여 원형 배열의 특성을 효과적으로 처리하였습니다. 이를 통해 문자열의 처음과 끝이 연결된 구조를 자연스럽게 다룰 수 있습니다.
- **포괄적인 경우 고려**: 'a'를 연속으로 만드는 경우와 'b'를 연속으로 만드는 경우를 모두 고려하여 최소 교환 횟수를 계산한 점이 잘 설계되었습니다.

### 2. 개선 및 보완이 필요한 점
- **슬라이딩 윈도우의 효율성**: 현재 슬라이딩 윈도우를 구현할 때, 각 창(window)마다 전체를 다시 검사하고 있습니다. 이는 불필요한 반복이 발생하여 시간 복잡도를 증가시킬 수 있습니다. 윈도우의 처음과 끝만을 업데이트하는 방식으로 최적화할 필요가 있습니다.
- **데크(deque) 사용의 적절성**: `deque`와 `rotate`를 사용하여 원형 배열을 처리하는 것은 직관적이지만, 인덱스를 활용한 단순한 순환 처리가 더 효율적일 수 있습니다. 특히, 문자열 길이가 최대 1,000이므로 인덱스를 이용한 접근이 충분히 빠를 것입니다.
- **중복 계산의 최소화**: 'a'와 'b'에 대해 각각 슬라이딩 윈도우를 적용하는 대신, 한 번의 순회로 두 경우를 동시에 처리할 수 있는 방법을 모색하면 코드의 효율성과 가독성을 높일 수 있습니다.

### 3. 생각해볼 부분
- **윈도우 내 교환 횟수 최적화**: 현재는 각 윈도우 내에서 비연속 문자의 수를 단순히 세고 있지만, 실제 교환 위치를 최적화하여 더 적은 교환으로 목표를 달성할 수 있는지 고민해볼 필요가 있습니다.
- **알고리즘의 시간 복잡도 분석**: 입력 문자열의 최대 길이가 1,000이므로 현재 구현 방식이 충분히 빠를 수 있지만, 보다 효율적인 알고리즘을 적용하여 시간 복잡도를 줄일 수 있는지 검토해보면 좋겠습니다.
- **특수 케이스 처리**: 모든 문자가 동일한 경우나, 'a' 또는 'b'가 전혀 없는 경우 등 특수한 상황에서의 동작을 추가로 고려하여 코드의 안정성을 높일 수 있습니다.

---

위 리뷰가 도움이 되었기를 바랍니다. 추가적인 질문이나 다른 코드 리뷰가 필요하면 언제든지 알려주세요!
