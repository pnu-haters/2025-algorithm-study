# 문제
**제목**: 회전 초밥  
**시간 제한**: 1 초  
**메모리 제한**: 256 MB  

**설명**: 
회전 초밥 음식점에는 회전하는 벨트 위에 여러 가지 종류의 초밥이 접시에 담겨 놓여 있고, 손님은 이 중에서 자기가 좋아하는 초밥을 골라서 먹는다. 초밥의 종류를 번호로 표현할 때, 다음 그림은 회전 초밥 음식점의 벨트 상태의 예를 보여주고 있다. 벨트 위에는 같은 종류의 초밥이 둘 이상 있을 수 있다. 

새로 문을 연 회전 초밥 음식점이 불경기로 영업이 어려워서, 다음과 같이 두 가지 행사를 통해서 매상을 올리고자 한다.

원래 회전 초밥은 손님이 마음대로 초밥을  고르고, 먹은 초밥만큼 식대를 계산하지만, 벨트의 임의의 한 위치부터 k개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공한다. 
각 고객에게 초밥의 종류 하나가 쓰인 쿠폰을 발행하고, 1번 행사에 참가할 경우 이 쿠폰에 적혀진 종류의 초밥 하나를 추가로 무료로 제공한다. 만약 이 번호에 적혀진 초밥이 현재 벨트 위에 없을 경우, 요리사가 새로 만들어 손님에게 제공한다.  

위 할인 행사에 참여하여 가능한 한 다양한 종류의 초밥을 먹으려고 한다. 위 그림의 예를 가지고 생각해보자. k=4이고, 30번 초밥을 쿠폰으로 받았다고 가정하자. 쿠폰을 고려하지 않으면 4가지 다른 초밥을 먹을 수 있는 경우는 (9, 7, 30, 2), (30, 2, 7, 9), (2, 7, 9, 25) 세 가지 경우가 있는데, 30번 초밥을 추가로 쿠폰으로 먹을 수 있으므로 (2, 7, 9, 25)를 고르면 5가지 종류의 초밥을 먹을 수 있다. 
회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오. 
  
**입력**: 
첫 번째 줄에는 회전 초밥 벨트에 놓인 접시의 수 N, 초밥의 가짓수 d, 연속해서 먹는 접시의 수 k, 쿠폰 번호 c가 각각 하나의 빈 칸을 사이에 두고 주어진다. 단, 2 ≤ N ≤ 30,000, 2 ≤ d ≤ 3,000, 2 ≤ k ≤ 3,000 (k ≤ N), 1 ≤ c ≤ d이다. 두 번째 줄부터 N개의 줄에는 벨트의 한 위치부터 시작하여 회전 방향을 따라갈 때 초밥의 종류를 나타내는 1 이상 d 이하의 정수가 각 줄마다 하나씩 주어진다. 
  
**출력**: 
주어진 회전 초밥 벨트에서 먹을 수 있는 초밥의 가짓수의 최댓값을 하나의 정수로 출력한다.
  


## Jimin-K04
BOJ_2531_회전초밥.cpp

```cpp
//입력값을 배열에 저장한다
//윈도우 크기를 잡고
//초밥 종류별 윈도우 안에 몇개가 있는지 저장하는 배열 생성, 초밥의 종류가 3000이하
//스마트 포인터를 써볼까?, 회전초밥 벨트 배열 동적 할당
//*윈도우마다 종류 max 값 갱신해주기,, 쿠폰도 고려해야하니까 쿠폰 과 같은 종류가 있는지 없는지 확인하고 max 값 설정*/
#include <iostream>
#include <memory> // 스마트 포인터 사용
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int belt_size, kindCount, window_size, coupon_num;
	cin >> belt_size >> kindCount >> window_size >> coupon_num;

	unique_ptr<int[]> belt{ new int[belt_size] }; //스마트 포인터로 동적 할당
	unique_ptr<int[]> count_types{ new int[kindCount+1] };

	for (int i = 0; i < belt_size; i++) cin >> belt[i];

	int left = 0, right = window_size - 1; //윈도우 설정
	int type_num = 0; //윈도우 안에있는 초밥의 종류를 셈
	int check_coupon = 1; //윈도우 안에 쿠폰이 있으면 0, 없으면 1

	for (int i = 0; i < window_size; i++) {
		if (!count_types[belt[i]]) type_num++; //새로운 종류의 초밥일 경우 count..
		count_types[belt[i]]++;
		if (belt[i] == coupon_num) check_coupon = 0;
	}
	int max_type_count = type_num + check_coupon; //윈도우 내의 가장 많은 종류의 수를 저장하는 변수

	while (left < belt_size) { //360 회전할때까지 반복
		if (belt[left] == coupon_num && count_types[belt[left]] == 1) check_coupon = 1; // 쿠폰과 같은 종류의 초밥이 윈도우에서 제거 됨
		if (--count_types[belt[left++]] == 0) type_num--; //왼쪽 포인터 값 제거 해주고 0개이면 type_num 갱신, 
		
		right = (right + 1) % belt_size; //원형 큐? 느낌
		if (count_types[belt[right]]++ == 0) type_num++;
		if (belt[right] == coupon_num) check_coupon = 0;

		if (max_type_count < type_num + check_coupon) max_type_count = type_num + check_coupon;
	}
	cout << max_type_count;
}

```

### 1. 좋은 점
- **효율적인 슬라이딩 윈도우 구현**: 윈도우의 시작과 끝을 포인터(`left`, `right`)로 관리하며, 원형 벨트를 고려하여 모듈러 연산(`% belt_size`)을 적절히 사용한 점이 돋보입니다. 이를 통해 모든 가능한 윈도우를 효율적으로 탐색할 수 있습니다.
- **초밥 종류 카운트 관리**: `count_types` 배열을 사용하여 현재 윈도우 내 각 초밥의 개수를 정확히 추적하고, 새로운 초밥이 추가되거나 제거될 때마다 `type_num`을 적절히 업데이트하여 현재 종류의 수를 관리한 점이 잘 구현되어 있습니다.
- **쿠폰 처리 로직**: 초기 윈도우 설정 시 쿠폰 초밥(`coupon_num`)의 존재 여부를 체크하고, 윈도우가 이동할 때마다 쿠폰 초밥의 추가 여부를 정확히 판단하여 `max_type_count`를 업데이트하는 로직이 명확하게 구현되었습니다.
- **스마트 포인터 사용**: 메모리 관리를 위해 `unique_ptr`을 사용한 점은 메모리 누수를 방지하고 코드의 안전성을 높이는 좋은 방법입니다.

### 2. 개선 및 보완이 필요한 점
- **스마트 포인터 사용의 필요성 검토**: 현재 코드에서는 `unique_ptr`을 사용하여 배열을 동적 할당하고 있으나, 고정된 크기의 배열(`belt_size`와 `kindCount`)을 사용할 수 있다면 스마트 포인터 대신 벡터(`std::vector`)를 사용하는 것이 코드의 가독성과 관리 측면에서 더 유리할 수 있습니다.
- **초기 윈도우 설정 시 쿠폰 처리 로직**: 초기 윈도우 설정에서 `check_coupon`을 설정할 때, 윈도우 내에 쿠폰 초밥이 여러 개 있을 경우에도 단순히 `0`으로 설정하고 있습니다. 초밥의 개수를 기반으로 하는 로직으로 변경하여, 쿠폰 초밥이 여전히 윈도우 내에 존재하는지 정확히 판단할 필요가 있습니다.
  ```cpp
  // 예시 개선
  if (belt[i] == coupon_num) check_coupon = (count_types[coupon_num] > 1) ? 0 : 1;
  ```
- **변수 네이밍의 일관성**: 변수명에 일관성을 부여하면 코드의 가독성이 향상됩니다. 예를 들어, `kindCount`보다는 `d` 또는 `numKinds`와 같은 이름이 더 직관적일 수 있습니다.
- **루프 종료 조건 최적화**: 현재 루프는 `left < belt_size` 조건을 사용하여 모든 가능한 윈도우를 탐색하고 있습니다. 그러나 윈도우가 한 바퀴를 돌기 전에 최적의 값을 찾을 수 있는 경우 루프를 조기에 종료할 수 있는 로직을 고려해 볼 수 있습니다.

### 3. 생각해볼 부분
- **초밥 종류의 빈도수 최적화**: 현재 `count_types` 배열을 사용하여 각 초밥의 빈도수를 추적하고 있지만, 초밥의 종류가 많아질 경우 (예: `d`가 최대 3000) 배열 크기가 커질 수 있습니다. 이를 해시맵(`std::unordered_map`)이나 다른 자료구조로 대체하여 메모리 사용을 최적화하는 방안을 고려해볼 수 있습니다.
- **윈도우의 중복 처리 방지**: 벨트가 원형인 특성을 고려할 때, 특정 패턴이 반복될 가능성이 있습니다. 예를 들어, 동일한 종류의 초밥이 연속적으로 반복되는 경우, 중복된 윈도우를 처리하지 않도록 최적화하는 방법을 생각해 볼 수 있습니다.
- **쿠폰 초밥의 중복 제공 여부**: 문제에서 쿠폰 초밥의 추가 제공이 중복으로 허용되지 않는지에 대한 조건을 명확히 이해하고, 코드에서 이를 확실히 반영했는지 검토할 필요가 있습니다. 현재 로직에서는 쿠폰 초밥이 여러 개 있을 경우에도 추가로 하나만 제공하도록 되어 있으나, 다른 조건이 있을 수 있습니다.
- **시간 복잡도 분석**: 주어진 입력 범위 내에서 현재 구현이 시간 제한(1초)을 만족하는지에 대한 분석이 필요합니다. `N`이 최대 30,000이고, 각 윈도우 이동 시 상수 시간 연산을 수행하므로 전체 시간 복잡도는 O(N)으로 예상되지만, 실제 구현 시 상수 계수가 높지 않은지 검토할 필요가 있습니다.
- **경계 조건 테스트**: 특히, 모든 초밥이 동일한 종류이거나, 쿠폰 초밥이 없는 경우, 쿠폰 초밥이 항상 포함되는 경우 등 다양한 경계 조건을 고려하여 코드가 올바르게 동작하는지 추가적인 테스트가 필요합니다.

---

전반적으로 잘 구현된 코드이며, 효율적인 알고리즘을 사용하여 문제를 해결하고 있습니다. 위에서 언급한 개선 사항과 생각해볼 부분을 반영하면 코드의 완성도와 효율성을 더욱 높일 수 있을 것입니다.

## Leeseojun035
BOJ_2531_회전 초밥.cpp

```cpp
#include <iostream>
#include <vector>
#include <map>

using namespace std;
map<int,int> m;// map<key,value> key: 초밥번호, value: 초밥 conut

int result;
//슬라이딩 윈도우 알고리즘
void window(std::vector<int> vec, int consecutivePlates,int couponId,int totalPlates){
 
	auto it = vec.begin();
	auto window_end = vec.begin();
	m.clear();
	for(int i = 0; i<consecutivePlates;i++){
		m[*window_end++]++;// 연속되는 초밥 수만큼 윈도우 크기 늘려주기
		if(window_end==vec.end()) window_end = vec.begin();
	}


	for(int i= 0; i<totalPlates; i++){


		m[*window_end]++;
		if(m[*it]>1){
            m[*it]--;// 같은 초밥 2개 이상이면 1감소

		}
		else{
			m.erase(*it); // 1개면 map에서 삭제
		}

		m[couponId]++;//  쿠폰 추가해주기
		it++;
		window_end++;
		if(window_end==vec.end()) window_end = vec.begin();

		if(result<m.size()) result = m.size();//map size가 map 의 key개수

	}

}


int main(int argc, char** argv) {
	vector<int> lt;
	map<int,int> m;
	int totalPlates, totalSushiTypes,consecutivePlates,couponId;
	std::cin>>totalPlates>>totalSushiTypes>>consecutivePlates>>couponId;

	for(int i = 0; i<totalPlates; i++){
		int number;
		cin>>number;
		lt.push_back(number);
	}

	window(lt,consecutivePlates,couponId, totalPlates);

	cout<<result;





	}

```

### 1. 좋은 점
- **슬라이딩 윈도우 알고리즘 사용**: 연속된 접시의 초밥을 효율적으로 관리하기 위해 슬라이딩 윈도우 기법을 적절히 활용하였습니다. 이를 통해 시간 복잡도를 줄이고 문제를 효과적으로 해결하려는 시도가 돋보입니다.
- **맵을 이용한 초밥 종류 관리**: `map<int, int>`를 사용하여 현재 윈도우 내의 초밥 종류와 개수를 명확하게 관리하고 있습니다. 이를 통해 초밥의 종류별 빈도를 쉽게 추적할 수 있습니다.
- **벡터를 사용한 벨트 상태 저장**: 초밥 벨트의 상태를 `vector<int>`에 저장하여 인덱스를 통한 접근이 용이하게 구현되었습니다. 벨트가 원형이라는 점을 고려하여 반복되는 인덱스 처리를 잘 구현하였습니다.

### 2. 개선 및 보완이 필요한 점
- **글로벌 변수 사용 지양**: 코드에서 `map<int, int> m`과 `int result`를 글로벌 변수로 선언하여 함수 간의 의존성을 높였습니다. 이는 코드의 가독성과 유지보수성을 저하시킬 수 있으므로, 가능한 한 지역 변수로 변경하고 함수의 매개변수로 전달하는 것이 좋습니다.
- **맵 대신 배열 또는 벡터 사용 고려**: 초밥의 가짓수가 최대 3,000이므로, `map`보다 고정 크기의 `vector<int>`를 사용하여 초밥 종류별 빈도를 관리하면 접근 속도가 향상될 수 있습니다. 이는 특히 높은 빈도의 삽입과 삭제가 필요한 경우 성능 최적화에 도움이 됩니다.
  ```cpp
  vector<int> sushiCount(d+1, 0);
  ```
- **초기 윈도우 설정 시 쿠폰 처리 누락**: 초기 윈도우를 설정할 때 쿠폰으로 추가되는 초밥을 고려하지 않고 있습니다. 따라서 첫 번째 윈도우에서 쿠폰을 사용한 경우의 초밥 가짓수가 반영되지 않을 수 있습니다. 초기 윈도우 설정 후 한 번 쿠폰을 적용하는 로직이 필요합니다.
- **중복된 맵 선언**: `main` 함수 내에서 다시 한번 `map<int, int> m;`을 선언하고 있지만, 이는 글로벌 변수 `m`과 중복되어 혼란을 초래할 수 있습니다. 이러한 중복 선언은 제거하고 일관되게 글로벌 변수 또는 지역 변수를 사용하는 것이 좋습니다.
- **입력 처리 최적화**: 현재 `cin`을 사용하여 입력을 받고 있으나, 입력 데이터가 많을 경우 `cin`의 속도가 느려질 수 있습니다. `std::ios::sync_with_stdio(false);`와 `std::cin.tie(NULL);`을 추가하여 입출력 속도를 향상시킬 수 있습니다.
  ```cpp
  std::ios::sync_with_stdio(false);
  std::cin.tie(NULL);
  ```

### 3. 생각해볼 부분
- **쿠폰 초밥의 중복 처리**: 현재 코드에서는 각 윈도우마다 쿠폰 초밥을 무조건 추가하고 있습니다. 하지만 쿠폰 초밥이 이미 현재 윈도우에 포함되어 있는 경우, 추가되지 않도록 처리하는 것이 정확한 가짓수 계산에 필요합니다. 이를 위해 쿠폰 초밥의 존재 여부를 확인하고, 존재하지 않을 때만 추가하는 로직을 고려해볼 수 있습니다.
  ```cpp
  if (m.find(couponId) == m.end()) {
      currentUniqueCount += 1;
  }
  ```
- **더 효율적인 자료 구조 탐색**: `map`을 사용할 경우, 각 윈도우 이동 시 키 존재 여부를 탐색하는 데 추가적인 시간이 소요될 수 있습니다. `vector`를 사용하면 인덱스를 통한 직접 접근이 가능하므로, 시간 복잡도를 더욱 줄일 수 있습니다. 특히, 초밥의 가짓수가 제한적이므로 `vector`가 더 적합할 수 있습니다.
- **윈도우 이동 최적화**: 현재 윈도우를 이동할 때마다 `map`을 업데이트하고 있지만, 윈도우 내의 초밥 종류 수를 따로 관리하여 불필요한 연산을 줄일 수 있는 방법을 고민해볼 수 있습니다. 예를 들어, 초밥의 개수가 0이 되는 순간 가짓수를 감소시키는 방식으로 최적화할 수 있습니다.
- **테스트 케이스 다양화**: 다양한 크기와 패턴의 입력에 대해 코드가 올바르게 동작하는지 테스트하는 것이 중요합니다. 특히, 초밥 벨트에 쿠폰 초밥이 여러 번 등장하거나, 모든 초밥이 동일한 경우 등 다양한 시나리오를 고려하여 코드의 견고함을 검증해보는 것이 좋습니다.

---

이러한 개선점을 고려하여 코드를 수정하면 성능과 가독성 모두 향상될 수 있으며, 보다 안정적인 결과를 얻을 수 있을 것입니다. 스터디원들과 함께 이러한 부분들을 논의하고 최적의 해결책을 찾아보세요!

## Nayeeun5
BOJ_2531_회전초밥.cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, d, k, c, diff_sushi = 1; //diff_sushi는 중복포함하지 않는 개수
    cin >> N >> d >> k >> c;

    vector<int> sushi(N), cnt(d + 1, 0); 

    for (int &x : sushi)
        cin >> x;

    cnt[c] = 1;
    for (int i = 0; i < k; i++){
        if (cnt[sushi[i]]++ == 0) // 처음 나온 번호라면 diff++
            diff_sushi++;
    }

    int ans = diff_sushi;
    for (int i = 0; i < N; i++){
        if (cnt[sushi[i]]-- == 1) // 이미 있는거 일때
            diff_sushi--; // diff--
        if (cnt[sushi[(i + k) % N]]++ == 0)
            diff_sushi++;
        ans = max(ans, diff_sushi);
    }
    cout << ans;
}

```

### 1. 좋은 점
- **효율적인 슬라이딩 윈도우 적용**: 연속된 `k`개의 초밥을 효율적으로 관리하기 위해 슬라이딩 윈도우 방식을 사용하였고, 이를 통해 시간 복잡도를 줄였습니다.
- **쿠폰 처리 로직의 명확성**: 초기 `cnt[c] = 1` 설정을 통해 쿠폰 초밥을 별도로 관리하여, 초밥 가짓수 계산 시 자동으로 포함되도록 구현하였습니다.
- **모듈러 연산을 통한 순환 처리**: `(i + k) % N`을 사용하여 벨트가 순환됨을 효과적으로 처리하였고, 이를 통해 인덱스 초과 문제를 방지하였습니다.
- **초기 윈도우 설정의 정확성**: 처음 `k`개의 초밥을 정확히 카운트하고, 중복되지 않는 초밥의 수를 올바르게 계산하였습니다.

### 2. 개선 및 보완이 필요한 점
- **`diff_sushi` 초기화의 불명확성**: `diff_sushi`를 `1`로 초기화한 후, 쿠폰 초밥 `c`를 카운트에 포함시켰지만, 최초 윈도우에 `c`가 포함되어 있는 경우 중복으로 세어질 수 있습니다. 이를 방지하기 위한 추가 검증이 필요합니다.
- **배열 크기 최적화**: `cnt` 배열의 크기를 `d + 1`로 설정하였는데, 초밥의 번호가 최대 `d`이므로 이는 적절하지만, 메모리 사용 측면에서 더 최적화할 여지가 있는지 검토할 필요가 있습니다.
- **코드 가독성 향상**: `diff_sushi` 변수의 역할을 명확히 하기 위해 주석을 추가하거나 변수명을 보다 직관적으로 변경할 수 있습니다. 예를 들어, `unique_sushi_count`와 같은 이름이 가독성을 높일 수 있습니다.
- **입력 방식 통일**: `std::cin`을 사용하여 입력을 받고 있는데, 문제의 입력 크기가 최대 30,000이므로 `scanf`와 같은 더 빠른 입력 방식을 고려할 수 있습니다. 또는 `std::cin`의 속도를 최적화하기 위해 `std::ios::sync_with_stdio(false);`와 `std::cin.tie(NULL);`을 명확히 설정하였습니다.

### 3. 생각해볼 부분
- **쿠폰 초밥의 중복 처리**: 쿠폰 초밥 `c`가 현재 슬라이딩 윈도우에 이미 포함되어 있을 경우, 추가로 하나를 더 제공하지 않아도 초밥 가짓수에는 변화가 없습니다. 이 경우를 어떻게 처리할지에 대한 논리가 포함되어야 합니다. 예를 들어, 윈도우 내에 `c`가 이미 있는지 여부를 체크하여 `diff_sushi`를 조정할 필요가 있습니다.
- **최대 가짓수 갱신 로직의 최적화**: 현재 매 반복마다 `max` 함수를 호출하여 최대 값을 갱신하고 있는데, 이 부분을 최적화하여 불필요한 연산을 줄일 수 있는지 검토해볼 수 있습니다.
- **경계 조건 테스트**: `k`가 `N`과 같은 경우 또는 `c`가 윈도우 내에 여러 번 등장하는 경우 등, 다양한 경계 조건에서 코드가 올바르게 동작하는지 추가적인 테스트가 필요합니다.
- **메모리 효율성**: 초밥의 종류가 최대 3,000까지 주어지므로, `cnt` 배열 대신 `unordered_map`이나 `bitset`과 같은 자료구조를 사용하여 메모리 사용을 최적화할 수 있는지 고려해볼 수 있습니다.

추가로, 쿠폰 초밥이 현재 슬라이딩 윈도우에 포함되어 있는지를 체크하여 `diff_sushi`의 중복 계산을 방지하는 로직을 도입하면 더 정확한 가짓수를 구할 수 있을 것입니다. 예를 들어, 초밥을 추가할 때 현재 창에 `c`가 포함되어 있는지를 확인한 후, 그에 따라 `diff_sushi`를 조정하는 방식으로 개선할 수 있습니다.

## cjaewon
BOJ_2531_회전 초밥.py

```py
import sys
from collections import deque

"""
슬라이싱 윈도우를 이용하여 푸는 문제이다.

sushi를 배열로 할지 딕셔너리로 할 지 고민했는데, 배열로 할 때 초밥 종류의 개수를 셀 때 O(N)이 걸리므로 O(1)이 걸리는 딕셔너리를 선택하였다.
원형인 자료가 나오면 나의 경우에는 주로 deque와 rotate를 사용한다.

벨트에 놓인 회전초밥 개수만 다르고 내용은 같은 문제가 있다.
회전초밥 2 : https://www.acmicpc.net/problem/15961

이 또한 똑같은 코드를 제출하니 풀림.
"""

N, d, k, c = map(int, input().split())
sushi = {}

dq = deque([])

for i in range(N):
 dq.append(int(sys.stdin.readline().rstrip()))

# 슬라이딩 윈도우를 위한 초기 윈도우 설정
for i in range(k):
  if dq[i] in sushi:
    sushi[dq[i]] += 1
  else:
    sushi[dq[i]] = 1

# 최대로 먹을 수 있는 스시의 종류
max_sushi_type = len(sushi.keys())

for i in range(N):

  sushi[dq[0]] -= 1
  if sushi[dq[0]] == 0:
    del sushi[dq[0]]

  if dq[k] not in sushi:
    sushi[dq[k]] = 1
  else:
    sushi[dq[k]] += 1
  
  if c in sushi.keys():
    if max_sushi_type < len(sushi.keys()):
      max_sushi_type = len(sushi.keys())
  else:
    if max_sushi_type < len(sushi.keys()) + 1:
      max_sushi_type = len(sushi.keys()) + 1

  dq.rotate(-1)

print(max_sushi_type)

```

### 1. 좋은 점
- **효율적인 자료구조 선택**: `deque`를 사용하여 회전 초밥 벨트의 원형 구조를 효과적으로 처리하고 있습니다. 슬라이딩 윈도우를 구현하는 데 `deque`의 `rotate` 메서드를 활용한 점이 좋습니다.
- **슬라이딩 윈도우 최적화**: 현재 윈도우에서 초밥의 개수를 관리하기 위해 딕셔너리를 사용하여 각 초밥 종류의 개수를 O(1)에 접근하고 업데이트할 수 있도록 구현하였습니다. 이는 시간 복잡도를 줄이는 데 기여합니다.
- **쿠폰 처리 로직 포함**: 쿠폰에 따른 추가 초밥의 종류를 고려하여 최종적인 최대 초밥 종류 수를 계산하는 로직이 잘 구현되어 있습니다.

### 2. 개선 및 보완이 필요한 점
- **덱 인덱싱의 위험성**: 슬라이딩 윈도우를 이동할 때 `dq[k]`로 접근하는 부분에서 인덱스 에러가 발생할 가능성이 있습니다. `deque`의 인덱스는 회전 후 변경되기 때문에, `k`가 `N`과 동일하거나 회전 과정에서 올바르게 순환되지 않으면 예외가 발생할 수 있습니다.
- **슬라이딩 윈도우 초기화 이후의 처리 부족**: 초기 윈도우를 설정한 후, 실제 슬라이딩 로직에서 다음 초밥을 추가할 때 `dq[k]` 대신 원형을 고려한 인덱싱이 필요합니다. 현재 구현에서는 `dq[k]`가 항상 올바른 다음 초밥을 가리키지 않을 수 있습니다.
- **시간 복잡도 최적화 부족**: 현재 코드에서는 `len(sushi.keys())`를 여러 번 호출하여 딕셔너리의 키 개수를 구하고 있습니다. 이는 불필요한 연산을 유발할 수 있으므로, 변수에 저장하여 재사용하는 방식으로 개선할 수 있습니다.

### 3. 생각해볼 부분
- **원형 슬라이딩 윈도우 처리의 안정성**: 벨트가 원형이므로 윈도우가 벨트의 끝을 넘어갈 때를 어떻게 처리할지 명확하게 구현되어야 합니다. 예를 들어, 인덱스를 `(i + k) % N`과 같이 모듈러 연산을 사용하여 순환시키는 방법을 고려해볼 수 있습니다.
- **쿠폰 초밥의 중복 처리**: 쿠폰으로 받은 초밥이 현재 윈도우에 포함되어 있는지 여부에 따라 가짓수를 다르게 계산하고 있습니다. 이 로직이 모든 경우에 대해 올바르게 작동하는지, 특히 초밥의 중복 여부가 많을 때의 처리를 더 면밀히 검토해볼 필요가 있습니다.
- **초밥 종류의 최대 가짓수 추적 최적화**: 현재 최대 가짓수를 업데이트하는 로직이 조건문 내에서 반복적으로 호출되고 있습니다. 이를 함수화하거나 더 효율적인 방식으로 최대 값을 추적할 수 있는지 고민해보는 것이 좋습니다.

---

코드의 전반적인 구조는 잘 작성되었으나, 위에서 언급한 부분들을 보완함으로써 더 안정적이고 효율적인 솔루션을 만들 수 있을 것입니다. 특히 슬라이딩 윈도우의 인덱싱과 원형 처리, 그리고 쿠폰 로직의 정확성을 재검토하는 것이 중요합니다.
